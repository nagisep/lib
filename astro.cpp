#include "astro.h"

TDateTime moon::lastNewMoonTime = 0;
TDateTime moon::nextNewMoonTime = 0;

astro::astro(TDateTime dtime)
{
  unsigned short year, month, day;

  pureDate = dtime;
  myDate  = dtime - TDateTime(9, 0, 0, 0);
  myDate.DecodeDate(&year, &month, &day);
  myDate += (57.0 + 0.8 * (year - 1990.0)) / 86400.0;  // 時点補正のデルタを加算する
  ut2jd();
}

void astro::ut2jd()
{
    unsigned short year, month, day;
    unsigned short hour, min, sec, msec;
    int  bc, gregory;

    myDate.DecodeDate(&year, &month, &day);
    myDate.DecodeTime(&hour, &min, &sec, &msec);

    bc = year <= 0;

    /* First day at Gregory's calendar */
    gregory = year > 1582 || (year == 1582 && month > 10) ||
              (year == 1582 && month == 10 && day >= 15);

    if (month <= 2) {
        year--;
        month += 12;
    }

    if (hour < 12) {
        jDate = 0;
        jTime = 0.5;
    } else {
        jDate = 1;
        jTime = -0.5;
    }
    jTime += (hour*3600L + min*60 + sec)/86400.0;

    jDate += bc ? (year-3)/4 : year/4;
    if (gregory) jDate += 2 - year/100 + year/400;
    jDate += 1720994L + year*365L + (month+1)*30 + (month+1)*3/5 + day;
}

sun::sun(TDateTime dtime) : astro(dtime)
{init();}

void sun::pos()
{
    using namespace std;

    typedef struct { double k, a, b; } TBL;
    const TBL l[16] = {
    {  1.9147,  35999.05, 267.52 }, { -0.0048,  35999.05, 267.52 },
    {  0.0200,  71998.1,  265.1  }, {  0.0020,  32964.0,  158.0  },
    {  0.0018,     19.0,  159.0  }, {  0.0018, 445267.0,  208.0  },
    {  0.0015,  45038.0,  254.0  }, {  0.0013,  22519.0,  352.0  },
    {  0.0007,  65929.0,   45.0  }, {  0.0007,   3035.0,  110.0  },
    {  0.0007,   9038.0,   64.0  }, {  0.0006,  33718.0,  316.0  },
    {  0.0005,    155.0,  118.0  }, {  0.0005,   2281.0,  221.0  },
    {  0.0004,  29930.0,   48.0  }, {  0.0004,  31557.0,  161.0  }};
    const TBL c[8] = {
    {  0.016706,  35999.05, 177.53 }, { -0.000042,  35999.05, 177.53 },
    {  0.000139,  71998.0,  175.0  }, {  0.000031, 445267.0,  298.0  },
    {  0.000016,  32964.0,   68.0  }, {  0.000016,  45038.0,  164.0  },
    {  0.000005,  22519.0,  233.0  }, {  0.000005,  33718.0,  226.0  }};
    int i;
    double s, t, r;

    lat = 0; // 太陽の赤緯は、０としておく。

    t = (getJulius() - 2451545.0)/36525.0;
    s = 280.4659 + 36000.7695 * t;
    for (i = 0; i < 16; i++) {
        r = l[i].a * t + l[i].b;
        s += l[i].k * cos(r * 0.017453292519943);
    }
    while (s < 0) s += 360.0;
    while (s >= 360.0) s-= 360.0;
    lng = s;

    s = 1.000140;
    for (i = 0; i < 8; i++) {
        r = c[i].a * t + c[i].b;
        s += c[i].k * cos(r * 0.017453292519943);
    }
    distance = s * AUDistance;
}

moon::moon(TDateTime dtime) : astro(dtime)
{
  init();
}

void moon::pos()
{
    using namespace std;

    typedef struct { double k, a, b; } TBL;
    const TBL ln[61] = {
    { 6.2888, 477198.868, 44.963 },{ 1.274,  413335.35,  10.74 },
    { 0.6583, 890534.22, 145.7  }, { 0.2136, 954397.74, 179.93 },
    { 0.1851,  35999.05,  87.53 }, { 0.1144, 966404.0,  276.5  },
    { 0.0588,  63863.5,  124.2  }, { 0.0571, 377336.3,   13.2  },
    { 0.0533,1367733.1,  280.7  }, { 0.0458, 854535.2,  148.2  },
    { 0.0409, 441199.8,   47.4  }, { 0.0347, 445267.1,   27.9  },
    { 0.0304, 513179.9,  222.5  }, { 0.0154,  75870.0,   41.0  },
    { 0.0125,1443603.0,   52.0  }, { 0.0110, 489205.0,  142.0  },
    { 0.0107,1303870.0,  246.0  }, { 0.0100,1431597.0,  315.0  },
    { 0.0085, 826671.0,  111.0  }, { 0.0079, 449334.0,  188.0  },
    { 0.0068, 926533.0,  323.0  }, { 0.0052,  31932.0,  107.0  },
    { 0.0050, 481266.0,  205.0  }, { 0.0040,1331734.0,  283.0  },
    { 0.0040,1844932.0,   56.0  }, { 0.0040,    133.0,   29.0  },
    { 0.0038,1781068.0,   21.0  }, { 0.0037, 541062.0,  259.0  },
    { 0.0028,   1934.0,  145.0  }, { 0.0027, 918399.0,  182.0  },
    { 0.0026,1379739.0,   17.0  }, { 0.0024,  99863.0,  122.0  },
    { 0.0023, 922466.0,  163.0  }, { 0.0022, 818536.0,  151.0  },
    { 0.0021, 990397.0,  357.0  }, { 0.0021,  71998.0,   85.0  },
    { 0.0021, 341337.0,   16.0  }, { 0.0018, 401329.0,  274.0  },
    { 0.0016,1856938.0,  152.0  }, { 0.0012,1267871.0,  249.0  },
    { 0.0011,1920802.0,  186.0  }, { 0.0009, 858602.0,  129.0  },
    { 0.0008,1403732.0,   98.0  }, { 0.0007, 790672.0,  114.0  },
    { 0.0007, 405201.0,   50.0  }, { 0.0007, 485333.0,  186.0  },
    { 0.0007,  27864.0,  127.0  }, { 0.0006, 111869.0,   38.0  },
    { 0.0006,2258267.0,  156.0  }, { 0.0005,1908795.0,   90.0  },
    { 0.0005,1745069.0,   24.0  }, { 0.0005, 509131.0,  242.0  },
    { 0.0004,  39871.0,  223.0  }, { 0.0004,  12006.0,  187.0  },
    { 0.0003, 958465.0,  340.0  }, { 0.0003, 381404.0,  354.0  },
    { 0.0003, 349472.0,  337.0  }, { 0.0003,1808933.0,   58.0  },
    { 0.0003, 549197.0,  220.0  }, { 0.0003,   4067.0,   70.0  },
    { 0.0003,2322131.0,  191.0  }};
    const TBL la[45] = {
    { 5.1281, 483202.019,  3.273}, { 0.2806, 960400.89, 138.24 },
    { 0.2777,   6003.15,  48.31 }, { 0.1733, 407332.20,  52.43 },
    { 0.0554, 896537.4,  104.0  }, { 0.0463,  69866.7,   82.5  },
    { 0.0326,1373736.2,  239.0  }, { 0.0172,1437599.8,  273.2  },
    { 0.0093, 884531.0,  187.0  }, { 0.0088, 471196.0,   87.0  },
    { 0.0082, 371333.0,   55.0  }, { 0.0043, 547066.0,  217.0  },
    { 0.0042,1850935.0,   14.0  }, { 0.0034, 443331.0,  230.0  },
    { 0.0025, 860538.0,  106.0  }, { 0.0022, 481268.0,  308.0  },
    { 0.0022,1337737.0,  241.0  }, { 0.0021, 105866.0,   80.0  },
    { 0.0019, 924402.0,  141.0  }, { 0.0018, 820668.0,  153.0  },
    { 0.0018, 519201.0,  181.0  }, { 0.0018,1449606.0,   10.0  },
    { 0.0015,  42002.0,   46.0  }, { 0.0015, 928469.0,  121.0  },
    { 0.0015, 996400.0,  316.0  }, { 0.0014,  29996.0,  129.0  },
    { 0.0013, 447203.0,    6.0  }, { 0.0013,  37935.0,   65.0  },
    { 0.0011,1914799.0,   48.0  }, { 0.0010,1297866.0,  288.0  },
    { 0.0009,1787072.0,  340.0  }, { 0.0008, 972407.0,  235.0  },
    { 0.0007,1309873.0,  205.0  }, { 0.0006, 559072.0,  134.0  },
    { 0.0006,1361730.0,  322.0  }, { 0.0005, 848532.0,  190.0  },
    { 0.0005, 419339.0,  149.0  }, { 0.0005, 948395.0,  222.0  },
    { 0.0004,2328134.0,  149.0  }, { 0.0004,1024264.0,  352.0  },
    { 0.0003, 932536.0,  282.0  }, { 0.0003,1409735.0,   57.0  },
    { 0.0003,2264270.0,  115.0  }, { 0.0003,1814936.0,   16.0  },
    { 0.0003, 335334.0,   57.0  }};
    const TBL c[43] = {
    { 0.051820, 477198.868,134.963}, { 0.009530, 413335.35, 100.74 },
    { 0.007842, 890534.22, 235.7  }, { 0.002824, 954397.74, 269.93 },
    { 0.000858,1367733.1,   10.7  }, { 0.000531, 854535.2,  238.2  },
    { 0.000400, 377336.3,  103.2  }, { 0.000319, 441199.8,  137.4  },
    { 0.000271, 445267.0,  118.0  }, { 0.000263, 513198.0,  312.0  },
    { 0.000197, 489205.0,  232.0  }, { 0.000173,1431597.0,   45.0  },
    { 0.000167,1303870.0,  336.0  }, { 0.000111,  35999.0,  178.0  },
    { 0.000103, 826671.0,  201.0  }, { 0.000084,  63864.0,  214.0  },
    { 0.000083, 926533.0,   53.0  }, { 0.000078,1844932.0,  146.0  },
    { 0.000073,1781068.0,  111.0  }, { 0.000064,1331734.0,   13.0  },
    { 0.000063, 449334.0,  278.0  }, { 0.000041, 481266.0,  295.0  },
    { 0.000034, 918399.0,  272.0  }, { 0.000033, 541062.0,  349.0  },
    { 0.000031, 922466.0,  253.0  }, { 0.000030,  75870.0,  131.0  },
    { 0.000029, 990397.0,   87.0  }, { 0.000026, 818536.0,  241.0  },
    { 0.000023, 553069.0,  266.0  }, { 0.000019,1267871.0,  339.0  },
    { 0.000013,1403732.0,  188.0  }, { 0.000013, 341337.0,  106.0  },
    { 0.000013, 401329.0,    4.0  }, { 0.000012,2258267.0,  246.0  },
    { 0.000011,1908795.0,  180.0  }, { 0.000011, 858602.0,  219.0  },
    { 0.000010,1745069.0,  114.0  }, { 0.000009, 790672.0,  204.0  },
    { 0.000007,2322131.0,  281.0  }, { 0.000007,1808933.0,  148.0  },
    { 0.000006, 485333.0,  276.0  }, { 0.0000006, 99863.0,  212.0  },
    { 0.000005, 405201.0,  140.0  }};
    int i;
    double s, t, r;

    t = (getJulius() - 2451545.0)/36525.0;
    s = 218.3162 + 481267.8809 * t;
    for (i = 0; i < 61; i++) {
        r = ln[i].a * t + ln[i].b;
        s += ln[i].k * cos(r * 0.017453292519943);
    }
    while (s < 0) s += 360.0;
    while (s >= 360.0) s-= 360.0;
    lng = s;

    s = 0.0;
    for (i = 0; i < 45; i++) {
        r = la[i].a * t + la[i].b;
        s += la[i].k * cos(r * 0.017453292519943);
    }

    do
    {
      if (s < -90) s += 360;
      if (s > 90)  s -= 360;
    } while((s < -90) || (s > 90));

    lat = s;

    s = 0.950725;
    for (i = 0; i < 43; i++) {
        r = c[i].a * t + c[i].b;
        s += c[i].k * cos(r * 0.017453292519943);
    }
    distance = 6378.14 / sin(s * 0.017453292519943);
}

double moon::getPhase() const
{
  double rikaku;
  sun nowSun(pureDate);

  rikaku = getLng() - nowSun.getLng();
  if (rikaku < 0) rikaku += 360;

  double phase = rikaku / 360;
  phase *= 28;

  return phase;
}

double moon::getAge() const
{
  return static_cast<double>(pureDate) - static_cast<double>(moon::getLastNewMoon(pureDate));
}

void moon::makeNewMoonList(TDateTime now)
{
  struct TimePhasePaireDef
  {
     TDateTime timePos;
     double    phase;
  };

  const TDateTime checkStep[4]  = 
  { 20.0 / 24.0,                // = 20hours
     1.0 / 24.0,                // =  1hour
     1.0 / 24.0 / 60.0,         // =  1minute
     1.0 / 24.0 / 60.0 / 60.0,  // =  1second
  };
  TimePhasePaireDef diff;
  TimePhasePaireDef base;

  base.timePos = now;
  base.phase   = moon(now).getPhase();

  for(int i = 0; i < 4; i++)
  {
    while(1)
    {
      diff.timePos = base.timePos - checkStep[i];
      diff.phase   = moon(diff.timePos).getPhase();
      // diff の方を「前」にしているので、通常部分は、 diff < base
      // この関係が反転するところが、朔のポイント
      if (diff.phase > base.phase) break;

      // 通常部分なら、diff にしたところを新たな base として、再計算
      base = diff;
    }

    // ここに抜けたときには、base と diff の間に朔のポイントがある
    // base を基準にして、次の時間単位で、再度検証を行う。
    // base からさかのぼるので、base のほうを固定する（ので、なにもしなくていい）
  }

  lastNewMoonTime = base.timePos;

  // 引き続き、次の新月の取得

  base.timePos = lastNewMoonTime;
  base.phase   = moon(lastNewMoonTime).getPhase();

  for(int i = 0; i < 4; i++)
  {
    while(1)
    {
      diff.timePos = base.timePos + checkStep[i];
      diff.phase   = moon(diff.timePos).getPhase();
      // diff の方を「後」にしているので、通常部分は、 diff > base
      // この関係が反転するところが、朔のポイント
      if (diff.phase < base.phase) break;

      // 通常部分なら、diff にしたところを新たな base として、再計算
      base = diff;
    }

    // ここに抜けたときには、base と diff の間に朔のポイントがある
    // base を基準にして、次の時間単位で、再度検証を行う。
    // base から後ろの時刻に延ばすので、base のほうを固定する（ので、なにもしなくていい）
  }
  nextNewMoonTime = base.timePos;
}

TDateTime moon::getLastNewMoon(TDateTime now)
{
  if (! ((now >= lastNewMoonTime) && (now < nextNewMoonTime)))
    makeNewMoonList(now);

  return lastNewMoonTime;
}


TDateTime moon::getNextNewMoon(TDateTime now)
{
  if (! ((now >= lastNewMoonTime) && (now < nextNewMoonTime)))
    makeNewMoonList(now);

  return nextNewMoonTime;
}
