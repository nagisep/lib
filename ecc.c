// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//   形式           : V680-CH1D
//   ファイル名     : ecc.c
//   処理概要       : CRC および、ECC の処理関数
//   作成者         : 藤原
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

#include "u:/lib/ecc.h"

static unsigned int bitCount;			// ECC 算出用のビット位置カウント変数
										// ECC 算出において、現在計算しているビ
										// ット位置を保持する。
										// ECC 算出が終了した時点では、最後に計
										// 算を行ったビット位置＝算出総ビット数
										// を保持している。
static unsigned int eccP;				// ECC 算出において、P 側のビットを保持
										// するためのデータ。P 側で16bit （全体
										// で32bit）までを保持することができる。
static unsigned int eccQ;				// ECC 算出において、Q 側のビットを保持
										// するためのデータ。P 側で16bit （全体
										// で32bit）までを保持することができる。


// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECC データ初期化
//
//  2.パラメタ説明
//    なし
//
//  3.概要
//    ECC 算出の初期化処理を行う
//    ECC 関連の関数の最初に呼び出す
//
//  4.機能説明
//    ECC 算出のための、bitカウント、P 系列、Q 系列の変数をクリアする
//
//  5.戻り値
//    なし
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

void initECC()
{
  bitCount = 0;
  eccP = 0;
  eccQ = 0;
}

// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECCデータ算出（１ビット）
//
//  2.パラメタ説明
//    c   ECC 処理をするための１ビット分の値を表現するデータ
//        0    : 該当ビットは '0',
//        0以外: 該当ビットは '1'
//
//  3.概要
//    ECC 処理関数
//    ECC 処理のために、１bit 分の データを足し込む
//
//  4.機能説明
//    ECC 処理のために、addECC() から呼び出される。
//    addECC() によって、１ビットごとに分解されたデータが渡される。
//    処理の単純化のために、 AaddECC() では、引数が 0 or not しかチェックしない
//
//  5.戻り値
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

static void AaddECC(unsigned char c)
{// 1 bit 分のデータを処理する
 // c は、zero or non-zer しか判定しない

  unsigned int dataWk;
  unsigned int maskWk;
 
  dataWk = (c == 0) ? 0 : 0xffff;  // 1bit 分を unsinged int に展開する

 maskWk = (~bitCount) & dataWk;
 eccP ^= maskWk;
 maskWk = bitCount & dataWk;
 eccQ ^= maskWk;
 bitCount++;
}

// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECCデータ算出（１バイト）
//
//  2.パラメタ説明
//    c   ECC 処理をするデータ１バイト分
//
//  3.概要
//    ECC 処理関数。
//    形式上、ECC を順次足し込むことで ECC の算出を行う
//
//  4.機能説明
//    ECC を算出する。ECC 算出においては、１）データクリア ２）各データ計算
//    ３）ECC 結果取得　のステップで実行される。
//    ２）のステップを受け持つ関数である。
//
//  5.戻り値
//    なし
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

void addECC(unsigned char c)
{ // 1 byte 分のデータを処理する

  AaddECC(c & 0x01);
  AaddECC(c & 0x02);
  AaddECC(c & 0x04);
  AaddECC(c & 0x08);

  AaddECC(c & 0x10);
  AaddECC(c & 0x20);
  AaddECC(c & 0x40);
  AaddECC(c & 0x80);
}

// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECCデータ取得
//
//  2.パラメタ説明
//    なし
//
//  3.概要
//    ECC を算出・取得する
//    一連の ECC 算出関数の最後に実行するもの
//
//  4.機能説明
//    ECC 値の取得。
//
//  5.戻り値
//    あらかじめ設定されたデータの ECC 値
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

unsigned long getECC()
{
   unsigned long result = 0;
   int i;
   unsigned int  iMask = 1;
   unsigned long rMask = 1;

   for (i = 0; i < 16; i++, iMask <<= 1)
   {
      if (eccP & iMask) result |= rMask;
      rMask <<= 1;
      if (eccQ & iMask) result |= rMask;
      rMask <<= 1;
   }

   if (bitCount <= 32 * 8)
     result &= 0x0000ffff;
   else if (bitCount <= 64 * 8)
     result &= 0x0003ffff;
   else if (bitCount <= 128 * 8)
     result &= 0x000fffff;
   else if (bitCount <= 256 * 8)
     result &= 0x003fffff;
   else
     result &= 0x00ffffff;

  return result;
}


// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECC可否判定
//
//  2.パラメタ説明
//    datCount    ECC を算出したデータのビット長
//    ECC1        比較用ECC(1)
//    ECC2        比較用ECC(2)
//
//  3.概要
//    ECC のエラー訂正を試みる
//
//  4.機能説明
//    ECC1, ECC2 を比較して、エラーの有無および、エラー訂正の可能性を判定する。
//
//  5.戻り値
//    -1 : ECC は正常であり、エラー訂正は不要だった
//    -2 : ECC は不正だが、エラー訂正はできなかった（２ビット以上のビット化けな
//    ど）
//    0 以上の数値 : １ビットのビット化けが検出された。そのビット位置（０始まり
//    ）を返す
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

int correctECC(int datCount, unsigned long ECC1, unsigned long ECC2)
{
  // dataCount 個のデータで算出された、 ECC1 と ECC2 を比較して、ビット化けが発生した箇所を、ビットシーケンス No. （０始まり）で返す。
  // 訂正箇所がない場合（ECC1 == ECC2） -1 を返す
  // ２ビット以上が化けていると思われる場合、 -2 を返す。
  int bitCount; // 有効な ECC のビット数
  int result = 0;
  int i;
  unsigned int mask;

  if (ECC1 == ECC2) return -1;

  if (datCount <= 32)
  {
     bitCount = 8;
     mask = 0x80;
  }
  else if (datCount <= 64)
  {
     bitCount = 9;
     mask = 0x100;
  }
  else if (datCount <= 128)
  {
     bitCount = 10;
     mask = 0x200;
  }
  else if (datCount <= 256)
  {
     bitCount = 11;
     mask = 0x400;
  }
  else
  {
     bitCount = 12;
     mask = 0x800;
  }
  

  ECC1 ^= ECC2; // 異なる部分を選び出す。
 
  // 相違位置を決める
  for (i = 0; i < bitCount; i++)
  {
    int modP;
    int modQ;

    result >>= 1;

    modP = ECC1 % 2;
    ECC1 >>= 1;
    modQ = ECC1 % 2;
    ECC1 >>= 1;

    if       ((modQ == 1) && (modP == 0)) result |= mask;
    else if  ((modQ == 0) && (modP == 1)) result |= 0; // この式は本質的には意味を持たないが、エラー処理のために書いてある
    else return -2;
  }

  return result;
}

// ****************************************************************************
//      (C) COPYRIGHT OMRON Corporation 2007 All Right Reserved
// ----------------------------------------------------------------------------
//  1.名称   :  ECC １ビット訂正
//
//  2.パラメタ説明
//    base    訂正を行うデータ列の先頭アドレス
//    bitPos  訂正を行うビット位置
//
//  3.概要
//    ECC エラーが発生した際に、ビット訂正を試みる。
//    どのビットを訂正するかは、correctETT() からの読み出しの際に通知される
//
//  4.機能説明
//    base から数えて（０始まり） bitPos 番目に相当するビットを反転させる
//
//  5.戻り値
//    なし
//
//  6.備考
// -----+--------+-----------+-------------------------------------------------
//  REV | 日付   | 作成者    | 内容                                          */
// -----+--------+-----------+-------------------------------------------------
//  1.00|07/09/22|   藤原    | 新規                                          */
// -----+--------+-----------+-------------------------------------------------
// *****************************************************************************

void correctBit(unsigned char *base, int bitPos)
{
  unsigned char wk = 1;
  unsigned char *data;

  data = base + (bitPos / 8);
  bitPos %= 8;
  wk <<= bitPos;
  (*data) ^= wk;
}

